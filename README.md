# leetcode

一个星期`日穿`leetcode


算法与数据结构是面试考察的重中之重，也是大家日后学习时需要着重训练的部分。简单的总结一下，大约有这些内容：

算法 - Algorithms

    排序算法：快速排序、归并排序、计数排序
    搜索算法：回溯、递归、剪枝技巧
    图论：最短路、最小生成树、网络流建模
    动态规划：背包问题、最长子序列、计数问题
    基础技巧：分治、倍增、二分、贪心
    
数据结构 - Data Structures

    数组与链表：单 / 双向链表、跳舞链
    栈与队列
    树与图：最近公共祖先、并查集
    哈希表
    堆：大 / 小根堆、可并堆
    字符串：字典树、后缀树



#### 递归模板

 - fibonacci数列
 - 无限分类


	function getChilds($all_items,$pid = 0)
	{
		if( base case){
			return [];
		}
		return getChilds($all_items,$new_pid);
	}


#### 回溯法

回溯使用的是递归思想,解的模板

    backtrack()
    
    if (base case) 
        paths.add;
        return;
    
    foreach(choice_list){
        make_choice;
        backtrack;
        remove_choice;
    }
    
暴力穷举

千万不要看不起暴力解，动态规划问题最困难的就是写出状态转移方程，即这个暴力解。优化方法无非是用备忘录或者 DP table，再无奥妙可言。
计算机解决问题其实没有任何奇技淫巧，它唯一的解决办法就是穷举，穷举所有可能性。算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。
之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。
备忘录、DP table 就是在追求“如何聪明地穷举”。用空间换时间的思路，是降低时间复杂度的不二法门，除此之外，试问，还能玩出啥花活？

等价于N叉树的遍历
等价于决策树的遍历

 - 迷宫求解
 - 全排列
 - BFS breath first search


	backtrack(){

		if( base case){
			all_path.add(cur_path);
			return;
		}

		for(){
			make_choice();
			backtrack();
			revoke_choice();
		}

	}


#### 动态规划

 - DFS depth first search
 - 凑零钱问题 

状态转移方程：

就是描述问题的数学公式 ， 人脑对值较大的数进行计算显得力不从心,所以我们需要通过 拆解结构使得 问题规模N变小,但是问题本质不变.	

比如说，

 1. 你的原问题是考出最高的总成绩，
 1. 那么你的子问题就是要把语文考到最高，数学考到最高…… 为了每门课考到最高，
 1. 你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高…… 当然，
 1. 最终就是你每门课都是满分，这就是最高的总成绩。

得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，“每门科目考到最高”这些子问题是互相独立，互不干扰的。

但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，此消彼长。
这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个 拆解思路 就会得到错误的结果。
因为子问题并不独立，语文数学成绩无法同时最优，所以最优子结构被破坏。

一、最优子结构详解
「最优子结构」是某些问题的一种特定性质，并不是动态规划问题专有的。也就是说，很多问题其实都具有最优子结构，只是其中大部分不具有重叠子问题，所以我们不把它们归为动态规划系列问题而已。

我先举个很容易理解的例子：假设你们学校有 10 个班，你已经计算出了每个班的最高考试成绩。那么现在我要求你计算全校最高的成绩，你会不会算？当然会，而且你不用重新遍历全校学生的分数进行比较，而是只要在这 10 个最高成绩中取最大的就是全校的最高成绩。

我给你提出的这个问题就符合最优子结构：可以从子问题的最优结果推出更大规模问题的最优结果。让你算每个班的最优成绩就是子问题，你知道所有子问题的答案后，就可以借此推出全校学生的最优成绩这个规模更大的问题的答案。

找最优子结构的过程，其实就是证明状态转移方程正确性的过程，方程符合最优子结构就可以写暴力解了，写出暴力解就可以看出有没有重叠子问题了，有则优化，无则 OK。这也是套路，经常刷题的朋友应该能体会。

那么遇到这种最优子结构失效情况，怎么办？策略是：改造问题

抽象契约到 接口， 这样 就算底层实现改变了，但是契约不变，接口仍旧可以使用.
上一代张起灵死了，有新的张起灵继承.虽然新旧行事方法不一样.但是目的相同.


递归的深度

实现算法以后 ，还要知道当前算法的时间复杂度 ，空间复杂度 是多少 

todo 什么时候 使用 滑动窗口 什么时候使用动态规划？
链表是否有环
层序遍历二叉树
缺失的数字
