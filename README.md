# leetcode

一个星期`日穿`leetcode


#### 递归模板

 - fibonacci数列
 - 无限分类


	function getChilds($all_items,$pid = 0)
	{
		if( base case){
			return [];
		}
		return getChilds($all_items,$new_pid);
	}


#### 回溯法

暴力穷举

千万不要看不起暴力解，动态规划问题最困难的就是写出状态转移方程，即这个暴力解。优化方法无非是用备忘录或者 DP table，再无奥妙可言。
计算机解决问题其实没有任何奇技淫巧，它唯一的解决办法就是穷举，穷举所有可能性。算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。
之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。
备忘录、DP table 就是在追求“如何聪明地穷举”。用空间换时间的思路，是降低时间复杂度的不二法门，除此之外，试问，还能玩出啥花活？

等价于N叉树的遍历
等价于决策树的遍历

 - 迷宫求解
 - 全排列
 - BFS breath first search


	backtrack(){

		if( base case){
			all_path.add(cur_path);
			return;
		}

		for(){
			make_choice();
			backtrack();
			revoke_choice();
		}

	}


#### 动态规划

 - DFS depth first search
 - 凑零钱问题 


状态转移方程：

就是描述问题的数学公式 ， 人脑对值较大的数进行计算显得力不从心,所以我们需要通过 拆解结构使得 问题规模N变小,但是问题本质不变.	

比如说，

 1. 你的原问题是考出最高的总成绩，
 1. 那么你的子问题就是要把语文考到最高，数学考到最高…… 为了每门课考到最高，
 1. 你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高…… 当然，
 1. 最终就是你每门课都是满分，这就是最高的总成绩。

得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，“每门科目考到最高”这些子问题是互相独立，互不干扰的。

但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，此消彼长。
这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个 拆解思路 就会得到错误的结果。
因为子问题并不独立，语文数学成绩无法同时最优，所以最优子结构被破坏。

抽象契约到 接口， 这样 就算底层实现改变了，但是契约不变，接口仍旧可以使用.
上一代张起灵死了，有新的张起灵继承.虽然新旧行事方法不一样.但是目的相同.
