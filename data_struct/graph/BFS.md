# 广度优先搜索

宽度优先搜索算法（又称广度优先搜索）是最简便的图的搜索算法之一，这一算法也是很多重要的图的算法的原型。
Dijkstra单源最短路径算法和Prim最小生成树算法都采用了和宽度优先搜索类似的思想(对穷举进行了优化)。
其别名又叫BFS，属于一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。
换句话说，它并不考虑结果的可能位置(不考虑权重)，彻底地搜索整张图，直到找到结果为止。

BFS，其英文全称是`Breadth First Search`。 BFS并不使用经验法则算法(就是说 BFS是纯穷举算法)。从算法的观点，所有因为展开节点而得到的子节点都会被加进一个先进先出的队列中。
一般的实验里，其邻居节点尚未被检验过的节点会被放置在一个被称为 open 的容器中（例如队列或是链表），
而被检验过的节点则被放置在被称为 closed 的容器中。（open-closed表）

## 详细解释

已知图G=(V,E)和一个源顶点s，宽度优先搜索以一种系统的方式探寻G的边，从而“发现”s所能到达的所有顶点，并计算s到所有这些顶点的距离(最少边数)，
该算法同时能生成一棵根为s且包括所有可达顶点的宽度优先树。

对从s可达的任意顶点v，宽度优先树中从s到v的路径对应于图G中从s到v的最短路径，即包含最小边数的路径。该算法对有向图和无向图同样适用。

之所以称之为宽度优先算法，是因为算法自始至终一直通过已找到和未找到顶点之间的边界向外扩展，
就是说，**算法首先搜索和s距离为k的所有顶点，然后再去搜索和S距离为k+l的其他顶点。**（像不像一层层向外荡漾的波纹）

广度优先是一种步步为营的策略，每次都从各个方向探索一步，将前线推进一步,
广度优先搜索还有一个特点是可以找到从起点到终点的最短路径，而深度优先搜索找到的不一定是最短路径.
深度优先只能保证找到的是一种可行路径,而不一定是最优路径.

为了保持搜索的轨迹，宽度优先搜索为每个顶点着色：白色、灰色或黑色。

 - 白色: 算法开始前所有顶点都是白色，随着搜索的进行，各顶点会逐渐变成灰色，然后成为黑色。
 - 灰色: 灰色顶点可以与一些白色顶点相邻接，它们代表着已找到和未找到顶点之间的边界。(也就是说 我们下一次开始遍历时，从灰色顶点开始)
 - 黑色: 已经发现的的顶点，并且不属于边界部分.
  
在搜索中第一次碰到一顶点时，我们说该顶点被发现，此时该顶点变为非白色顶点,因此，灰色和黑色顶点都已被发现。
但是，宽度优先搜索算法对它们加以区分以保证搜索以宽度优先的方式执行。
若`(u,v)∈E`且顶点u为黑色，那么顶点`v`要么是灰色，要么是黑色，就是说，所有和黑色顶点邻接的顶点都已被发现。

在宽度优先搜索过程中建立了一棵宽度优先树，起始时只包含根节点，即源顶点s.在扫描已发现顶点u的`邻接表`的过程中每发现一个白色顶点v，
该顶点v及边(u,v)就被添加到树中。

在宽度优先树中，我们称结点u 是结点v的先辈或父母结点。因为一个结点至多只能被发现一次，因此它最多只能有--个父母结点。
相对根结点来说祖先和后裔关系的定义和通常一样：如果u处于树中从根s到结点v的路径中，那么u称为v的`祖先`，v是u的`后裔`。（这俩词比较形象 精确 以后可以多用）

## BFS 代码实现

`三色原理` + `open-closed表`

假定输入图G=(V,E)采用邻接表表示，对于图中的每个顶点还采用了几种附加的数据结构